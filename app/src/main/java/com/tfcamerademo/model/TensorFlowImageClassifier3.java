/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nyou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\npackage com.tfcamerademo.model;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.AssetManager;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.widget.ImageView;\nimport android.graphics.Paint;\nimport android.graphics.Color;\nimport android.util.Log;\n\nimport com.tfcamerademo.Classifier;\n\nimport org.tensorflow.lite.Interpreter;\n\nimport java.util.List;\nimport java.util.Vector;\nimport java.lang.Math;\n\n/**\n * 骨架识别 并绘制关键点包括 头 鼻子 耳朵 眼睛  胳膊肘  肩膀 脖子 腿 膝盖 等等\n */\npublic class TensorFlowImageClassifier3 implements Classifier {\n\n    private static final String TAG = \"TensorFlowImageClassifier\";\n    private static Context context_instance;\n    private static ImageView imageview_instance;\n    private Vector<String> labels = new Vector<String>();\n    private Interpreter inferenceInterface;\n    private static final float NMS_Threshold = (float) 0.15;\n    private static final float Local_PAF_Threshold = (float) 0.2;\n    private static final int PAF_Count_Threshold = 5;\n    private static final int Part_Count_Threshold = 4;\n    private static final float Part_Score_Threshold = (float) 4.5;\n    private static final int MapHeight = 46;\n    private static final int MapWidth = 46;\n    private static final int HeatMapCount = 19;\n    private static final int MaxPairCount = 19;\n    private static final int PafMapCount = 38;\n    private static final int MaximumFilterSize = 5;\n    private static final int NumPafIter = 10;\n    private static final int[][] CocoPairs = {{1, 2}, {1, 5}, {2, 3}, {3, 4}, {5, 6}, {6, 7}, {1, 8}, {8, 9}, {9, 10}, {1, 11}, {11, 12}, {12, 13}, {1, 0}, {0, 14}, {14, 16}, {0, 15}, {15, 17}, {2, 16}, {5, 17}};\n    private static final int[][] CocoPairsNetwork = {{12, 13}, {20, 21}, {14, 15}, {16, 17}, {22, 23}, {24, 25}, {0, 1}, {2, 3}, {4, 5}, {6, 7}, {8, 9}, {10, 11}, {28, 29}, {30, 31}, {34, 35}, {32, 33}, {36, 37}, {18, 19}, {26, 27}};\n    private static final int[] CocoPartColor = {Color.RED, Color.MAGENTA, Color.CYAN, Color.CYAN, Color.CYAN, Color.CYAN, Color.CYAN, Color.CYAN, Color.YELLOW, Color.BLUE, Color.BLUE, Color.YELLOW, Color.BLUE, Color.BLUE, Color.RED, Color.RED, Color.RED, Color.RED};\n    private static final int DrawScale = 8;\n    private String inputName;\n    private String outputName;\n    private int inputSize_W;\n    private int inputSize_H;\n    private int imageMean;\n    private float imageStd;\n    private int[] raw_input_image;\n    private float[] rgb_input_image;\n    private float[] output_tensor;\n    private String[] outputNames;\n\n    private boolean logStats = false;\n\n    public static Classifier create(Context context, ImageView imageview, AssetManager assetManager, String modelFilename, String labelFilename,\                                    int inputSize_W, int inputSize_H, int imageMean, float imageStd, String inputName, String outputName) {\n        //实例化\n        TensorFlowImageClassifier3 classifier = new TensorFlowImageClassifier3();\n        classifier.inputName = inputName;\n        classifier.outputName = outputName;\n        classifier.inferenceInterface = new Interpreter(assetManager.openFd(modelFilename));\n        classifier.inputSize_W = inputSize_W;\n        classifier.inputSize_H = inputSize_H;\n        classifier.imageMean = imageMean;\n        classifier.imageStd = imageStd;\n        classifier.outputNames = new String[]{outputName};\n        classifier.raw_input_image = new int[inputSize_W * inputSize_H];\n        classifier.rgb_input_image = new float[inputSize_W * inputSize_H * 3];\n        classifier.output_tensor = new float[MapHeight * MapWidth * (HeatMapCount + PafMapCount)];\n        context_instance = context;\n        imageview_instance = imageview;\n        return classifier;\n    }\n\n    private void change_raw_to_rgb_inplace() {\n        //相机读取到的图像解释为三通道位图\n        long kk = System.currentTimeMillis();\n        for (int i = 0; i < raw_input_image.length; ++i) {\n            final int val = raw_input_image[i];\n            rgb_input_image[i * 3 + 2] = (byte)(val >> 16); //R\n            rgb_input_image[i * 3 + 1] = (byte)(val >> 8) ;  //G\n            rgb_input_image[i * 3 + 0] = (byte)val ;        //B\n\n        }\n        Log.e(\"abc\", System.currentTimeMillis() - kk+\"\");\n    }\n\n    @SuppressLint(\"LongLogTag\")\n    @Override\n    public List<Recognition> recognizeImage(final Bitmap bitmap) {\n        // 处理相机图像\n        // Preprocess image from camera\n        bitmap.getPixels(raw_input_image, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\n        change_raw_to_rgb_inplace();\n\n        // 将图像输入到tensorflow模型中运算，并将结果放到 outputName 里\n        // Copy the input data into TensorFlow.\n        inferenceInterface.runForMultipleInputsOutputs(new Object[]{rgb_input_image}, new String[]{outputName});\n        // Copy the output Tensor back into the output array.\n        inferenceInterface.getOutput(outputName, output_tensor);\n\n        // 定义一个vector数组存放所有的部位坐标（不同的人一起，相同部位放在一个vector里）\n        Vector<int[]> coords[] = new Vector[HeatMapCount - 1];\n\n        // 用最大滤波和非极大值抑制来过滤重复的点，尽量使得某一个人的某一个部位只会被取到一次\n        for (int i = 0; i < (HeatMapCount - 1); i++) {\n            coords[i] = new Vector<int[]>();\n            for (int j = 0; j < MapHeight; j++) {\n                for (int k = 0; k < MapWidth; k++) {\n                    int[] coord = {j, k};\n                    float max_value = 0;\n                    for (int dj = -(MaximumFilterSize - 1) / 2; dj < (MaximumFilterSize + 1) / 2; dj++) {\n                        if ((j + dj) >= MapHeight || (j + dj) < 0) {\n                            break;\n                        }\n                        for (int dk = -(MaximumFilterSize - 1) / 2; dk < (MaximumFilterSize + 1) / 2; dk++) {\n                            if ((k + dk) >= MapWidth || (k + dk) < 0) {\n                                break;\n                            }\n                            float value = output_tensor[(HeatMapCount + PafMapCount) * MapWidth * (j + dj) + (HeatMapCount + PafMapCount) * (k + dk) + i];\n                            if (value > max_value) {\n                                max_value = value;\n                            }\n                        }\n                    }\n                    if (max_value > NMS_Threshold) {\n                        if (max_value == output_tensor[(HeatMapCount + PafMapCount) * MapWidth * j + (HeatMapCount + PafMapCount) * k + i]) {\n                            coords[i].addElement(coord);\n                        }\n                    }\n                }\n            }\n        }\n\n        // 用paf算分数，并用贪心法来剔除不合理或者重复的连线\n        Vector<int[]> pairs[] = new Vector[MaxPairCount];\n        Vector<int[]> pairs_final[] = new Vector[MaxPairCount];\n        Vector<Float> pairs_scores[] = new Vector[MaxPairCount];\n        Vector<Float> pairs_scores_final[] = new Vector[MaxPairCount];\n        for (int i = 0; i < MaxPairCount; i++) {\n            pairs[i] = new Vector<int[]>();\n            pairs_scores[i] = new Vector<Float>();\n            pairs_final[i] = new Vector<int[]>();\n            pairs_scores_final[i] = new Vector<Float>();\n            Vector<Integer> part_set = new Vector<Integer>();\n            for (int p1 = 0; p1 < coords[CocoPairs[i][0]].size(); p1++) {\n                for (int p2 = 0; p2 < coords[CocoPairs[i][1]].size(); p2++) {\n                    int count = 0;\n                    float score = 0.0f;\n                    float scores[] = new float[10];\n                    int p1x = coords[CocoPairs[i][0]].get(p1)[0];\n                    int p1y = coords[CocoPairs[i][0]].get(p1)[1];\n                    int p2x = coords[CocoPairs[i][1]].get(p2)[0];\n                    int p2y = coords[CocoPairs[i][1]].get(p2)[1];\n                    float dx = p2x - p1x;\n                    float dy = p2y - p1y;\n                    float normVec = (float) Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n\n                    if (normVec < 0.0001f) {\n                        break;\n                    }\n                    float vx = dx / normVec;\n                    float vy = dy / normVec;\n                    for (int t = 0; t < 10; t++) {\n                        int tx = (int) ((float) p1x + (t * ((float) dx) / 9) + 0.5);\n                        int ty = (int) ((float) p1y + (t * ((float) dy) / 9) + 0.5);\n                        int location=tx * (HeatMapCount + PafMapCount) * MapWidth + ty * (HeatMapCount + PafMapCount) + HeatMapCount;\n                        scores[t] = vy * output_tensor[location + CocoPairsNetwork[i][0]];\n                        scores[t] += vx * output_tensor[location + CocoPairsNetwork[i][1]];\n                    }\n                    for(int h=0;h<10;h++)\n                    {\n                        if(scores[h]>Local_PAF_Threshold)\n                        {\n                            count+=1;\n                            score+=scores[h];\n                        }\n                    }\n                    if(score>0.0f && count>=PAF_Count_Threshold)\n                    {\n                        boolean inserted=false;\n                        int pair[]={p1,p2};\n                        for(int l=0;l<pairs[i].size();l++)\n                        {\n                            if (score>pairs_scores[i].get(l))\n                            {\n                                pairs[i].insertElementAt(pair,l);\n                                pairs_scores[i].insertElementAt(score,l);\n                                inserted=true;\n                                break;\n                            }\n                        }\n                        if (!inserted)\n                        {\n                            pairs[i].addElement(pair);\n                            pairs_scores[i].addElement(score);\n                        }\n                    }\n                }\n            }\n            for (int m=0;m<pairs[i].size();m++)\n            {\n                boolean conflict=false;\n                for(int n=0;n<part_set.size();n++)\n                {\n                    if (pairs[i].get(m)[0] == part_set.get(n) || pairs[i].get(m)[1] == part_set.get(n))\n                    {\n                        conflict=true;\n                        break;\n                    }\n                }\n                if (!conflict)\n                {\n                    pairs_final[i].addElement(pairs[i].get(m));\n                    pairs_scores_final[i].addElement(pairs_scores[i].get(m));\n                    part_set.addElement(pairs[i].get(m)[0]);\n                    part_set.addElement(pairs[i].get(m)[1]);\n                }\n            }\n        }\n\n        // 得到所有的连线集合后，用并查集算法，尽可能合并所有的连线，无法合并的多个部分即为多个人\n        class Human\n        {\n            /*Nose = 0\n            Neck = 1\n            RShoulder = 2\n            RElbow = 3\n            RWrist = 4\n            LShoulder = 5\n            LElbow = 6\n            LWrist = 7\n            RHip = 8\n            RKnee = 9\n            RAnkle = 10\n            LHip = 11\n            LKnee = 12\n            LAnkle = 13\n            REye = 14\n            LEye = 15\n            REar = 16\n            LEar = 17*/\n            public int parts_coords[][]=new int[18][2];\n            // not important\n            public int part_count=0;\n            public int coords_index_set[]=new int[18];\n            public boolean coords_index_asigned[]=new boolean[18];\n        }\n\n        Vector<Human> humans=new Vector<Human>();\n        Vector<Human> humans_final=new Vector<Human>();\n        for(int i=0;i<MaxPairCount;i++){\n            for(int j=0;j<pairs_final[i].size();j++)\n            {\n                boolean merged=false;\n                int p1=CocoPairs[i][0];\n                int p2=CocoPairs[i][1];\n                int ip1=pairs_final[i].get(j)[0];\n                int ip2=pairs_final[i].get(j)[1];\n                for(int k=0;k<humans.size();k++)\n                {\n                    Human human=humans.get(k);\n                    if((ip1 == human.coords_index_set[p1] && human.coords_index_asigned[p1]) || (ip2 == human.coords_index_set[p2] && human.coords_index_asigned[p2]))\n                    {\n                        human.parts_coords[p1]=coords[p1].get(ip1);\n                        human.parts_coords[p2]=coords[p2].get(ip2);\n                        human.coords_index_set[p1]=ip1;\n                        human.coords_index_set[p2]=ip2;\n                        human.coords_index_asigned[p1]=true;\n                        human.coords_index_asigned[p2]=true;\n                        merged=true;\n                        break;\n                    }\n                }\n                if(!merged)\n                {\n                    Human human=new Human();\n                    human.parts_coords[p1]=coords[p1].get(ip1);\n                    human.parts_coords[p2]=coords[p2].get(ip2);\n                    human.coords_index_set[p1]=ip1;\n                    human.coords_index_set[p2]=ip2;\n                    human.coords_index_asigned[p1]=true;\n                    human.coords_index_asigned[p2]=true;\n                    humans.addElement(human);\n                }\n            }\n        }\n\n\n        // 去掉部位数量过少的人\n        for(int i=0;i<humans.size();i++)\n        {\n            int human_part_count=0;\n            for(int j=0;j<HeatMapCount-1;j++)\n            {\n                if(humans.get(i).coords_index_asigned[j])\n                {\n                    human_part_count+=1;\n                }\n            }\n            if (human_part_count>Part_Count_Threshold)\n            {\n                humans_final.addElement(humans.get(i));\n            }\n        }\n\n        // 这里获得所有的人 保存在humans_final vector数组里，每一个human类都有一个长度为部位个数（18）的parts属性，第一个维度代表部位，解释在human类里，第二个维度是该部位的坐标。\n\n        Log.v(\"Number of Human in Screen\",String.valueOf(humans_final.size()));\n\n        // 画出所有的人\n        Bitmap bitmap_result = Bitmap.createBitmap(46*DrawScale, 46*DrawScale, Bitmap.Config.ARGB_8888);\n\n\n        Canvas canvas = new Canvas(bitmap_result);\n        Paint paint = new Paint();\n        paint.setStyle(Paint.Style.FILL);\n        paint.setStrokeWidth(1);  //线的宽度\n        for (int i = 0; i < (HeatMapCount - 1); i++) {\n            paint.setColor(CocoPartColor[i]);\n            for (int j = 0; j < coords[i].size(); j++) {\n                canvas.drawCircle(coords[i].get(j)[1]*DrawScale, coords[i].get(j)[0]*DrawScale,3, paint);\n            }\n        }\n\n        for (int i = 0; i < MaxPairCount; i++) {\n            paint.setColor(Color.GREEN);\n            for (int j = 0; j < pairs_final[i].size(); j++) {\n                int x1=coords[CocoPairs[i][0]].get(pairs_final[i].get(j)[0])[1]*DrawScale;\n                int y1=coords[CocoPairs[i][0]].get(pairs_final[i].get(j)[0])[0]*DrawScale;\n                int x2=coords[CocoPairs[i][1]].get(pairs_final[i].get(j)[1])[1]*DrawScale;\n                int y2=coords[CocoPairs[i][1]].get(pairs_final[i].get(j)[1])[0]*DrawScale;\n                canvas.drawLine(x1,y1,x2,y2,paint);\n            }\n        }\n\n        if (imageview_instance != null) {\n            imageview_instance.post(new Runnable() {\n                @Override\n                public void run() {\n                    imageview_instance.setImageBitmap(bitmap_result);\n                }\n            });\n\n        }\n\n        return null;\n    }\n\n    @Override\n    public void enableStatLogging(boolean logStats) {\n        this.logStats = logStats;\n    }\n\n    @Override\n    public String getStatString() {\n        return inferenceInterface.getStatString();\n    }\n\n    @Override\n    public void close() {\n        inferenceInterface.close();\n    }\n\n}